package TPs.TP6;

/**********************************************************************************************************************
 ************** @author Grupo 6 : Agustina Abalo, Tomas Berretta, Pedro Bogunovich, Tomas Bruno************************
 *********************************************************************************************************************/

class AVLTree<T> {

    DoubleNodeAVL<T> root;

    public AVLTree(){
        root = null;
    }

    public AVLTree(T o){
        root = new DoubleNodeAVL<>(o);
    }

    public AVLTree(T o, AVLTree<T> tleft, AVLTree<T> tright){
        root = new DoubleNodeAVL<>(o, tleft.root, tright.root);
    }

    public T getRootData(){
        return root.data;
    }

    public DoubleNodeAVL<T> getRootNode(){
        return root;
    }

    public boolean isEmpty(){
        return root == null;
    }

    public AVLTree<T> getLeft() {
        AVLTree<T> t = new AVLTree<>();
        t.root = root.left;
        return t;
    }

    public AVLTree<T> getRight() {
        AVLTree<T> t = new AVLTree<>();
        t.root = root.right;
        return t;
    }

    int height(AVLTree<T> avlTree) {
        if (avlTree.isEmpty())
            return 0;

        return avlTree.getRootNode().height;
    }

    AVLTree<T> rightRotate(AVLTree<T> y) {
        AVLTree<T> x = y.getLeft();
        AVLTree<T> z = x.getRight();

        // Perform rotation
        x.getRootNode().right = y.getRootNode();
        y.getRootNode().left = z.getRootNode(); //todo ver bien wtf

        // Update heights
        y.getRootNode().height = Math.max(height(y.getLeft()), height(y.getRight())) + 1;
        x.getRootNode().height = Math.max(height(x.getLeft()), height(x.getRight())) + 1;

        // Return new root
        return x;
    }

    AVLTree<T> leftRotate(AVLTree<T> x) {
        AVLTree<T> y = x.getRight();
        AVLTree<T> z = y.getLeft();

        // Perform rotation
        y.getRootNode().left = x.getRootNode();  //todo ver bien wtf
        x.getRootNode().right = z.getRootNode();

        // Update heights
        x.getRootNode().height = Math.max(height(x.getLeft()), height(x.getRight())) + 1;
        y.getRootNode().height = Math.max(height(y.getLeft()), height(y.getRight())) + 1;

        // Return new root
        return y;
    }

    int getBalance(AVLTree<T> x) {
        if (x.isEmpty()) return 0;
        return height(x.getLeft()) - height(x.getRight());
    }

    AVLTree<T> insert(AVLTree<T> x, Comparable<T> data) {

        /* 1.  Perform the normal BST insertion */
        if (x.isEmpty()) {
            x = new AVLTree<T>((T) data);
            return x;
        }
        else if (data.compareTo(x.root.data) < 0 )
            AVLTree<T> avlTree = new AVLTree<T>(insert(x.getLeft(), data).getRootNode()) ;
        else if (data.compareTo(x.root.data) > 0)
            x.root.right = insert(x.getRight(), data).getRootNode();
            //insert(x.getRight(), data);
        else // Duplicate keys not allowed
            return x;

        /* 2. Update height of this ancestor node */
        x.root.height = 1 + Math.max(height(x.getLeft()), height(x.getRight()));

        /* 3. Get the balance factor of this ancestor
              node to check whether this node became
              unbalanced */
        int balance = getBalance(x);

        // If this node becomes unbalanced, then there
        // are 4 cases Left Left Case
        if (balance > 1 && data.compareTo(x.root.left.data) < 0)
            return rightRotate(x);

        // Right Right Case
        if (balance < -1 && data.compareTo(x.root.right.data) > 0)
            return leftRotate(x);

        // Left Right Case
        if (balance > 1 && data.compareTo(x.root.left.data) > 0) {
            x.root.left = leftRotate(x.getLeft()).getRootNode();
            return rightRotate(x);
        }

        // Right Left Case
        if (balance < -1 && data.compareTo(x.root.right.data) < 0) {
            x.root.right = rightRotate(x.getRight()).getRootNode();
            return leftRotate(x);
        }

        /* return the (unchanged) node pointer */
        return x;
    }

    void preOrder(AVLTree<T> avlTree) {
        if (!avlTree.isEmpty()) {
            System.out.print(avlTree.root.data + " ");
            preOrder(avlTree.getLeft());
            preOrder(avlTree.getRight());
        }
    }
}
